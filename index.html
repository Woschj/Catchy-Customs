<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catchy Cases</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      color: #e0e0e0;
      background-color: #121212;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      font-weight: 600;
      margin-bottom: 20px;
      color: #ffffff;
      text-align: center;
      font-size: 2rem;
    }

    #container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      margin-right: 20px;
    }

    #controls label {
      font-size: 14px;
      margin-bottom: 8px;
      color: #b3b3b3;
    }

    #controls select, #controls input, #controls button {
      width: 200px;
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid #333;
      border-radius: 5px;
      font-size: 16px;
      font-family: inherit;
      background: #2c2c2c;
      color: #e0e0e0;
      outline: none;
      transition: border-color 0.2s ease;
    }

    #controls select:focus, #controls input:focus, #controls button:focus {
      border-color: #0071e3;
    }

    #dev-tools {
      background: #0071e3;
      color: white;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #dev-tools:hover {
      background: #005bb5;
    }

    #preview-canvas {
      border: 1px solid #333;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      background: #1e1e1e;
    }
  </style>
</head>
<body>
  <h1>Catchy Cases</h1>
  <div id="container">
    <div id="controls">
      <label for="manufacturer-select">Hersteller:</label>
      <select id="manufacturer-select"></select>
      
      <label for="model-select">Modell:</label>
      <select id="model-select"></select>
      
      <label for="design-select">Design:</label>
      <select id="design-select"></select>
      
      <label for="material-select">Material:</label>
      <select id="material-select"></select>
      
      <!-- Custom image functionality disabled for now -->
      <!--
      <label for="custom-upload">Eigenes Bild hochladen:</label>
      <input type="file" id="custom-upload" accept="image/*">
      
      <button id="apply-custom">Eigenes Bild anwenden</button>
      -->
      <button id="dev-tools">Dev-Tools aktivieren</button>
    </div>
    <canvas id="preview-canvas"></canvas>
  </div>
  
  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const REPO_OWNER = "Woschj";
      const REPO_NAME = "Catchy-Customs";
      const DESIGN_FOLDER = "design";
      const MATERIAL_FOLDER = "material";

      const manufacturerSelect = document.getElementById("manufacturer-select");
      const modelSelect = document.getElementById("model-select");
      const designSelect = document.getElementById("design-select");
      const materialSelect = document.getElementById("material-select");
      const previewCanvas = document.getElementById("preview-canvas");
      const devToolsButton = document.getElementById("dev-tools");
      const ctx = previewCanvas.getContext("2d");

      const CANVAS_WIDTH = 544;
      const CANVAS_HEIGHT = 544;
      previewCanvas.width = CANVAS_WIDTH;
      previewCanvas.height = CANVAS_HEIGHT;

      let maskRect = null;
      let drawing = false;

      function populateDropdown(dropdown, items, selectFirst = true) {
        dropdown.innerHTML = "";
        items.forEach((item, index) => {
          const option = document.createElement("option");
          option.value = item.url;
          option.textContent = item.name;
          dropdown.appendChild(option);
        });

        if (selectFirst && items.length > 0) {
          dropdown.selectedIndex = 0;
        }
      }

      async function fetchFolders(folder) {
        const response = await fetch(
          `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${folder}`
        );
        const folders = await response.json();
        return folders
          .filter((folder) => folder.type === "dir")
          .map((folder) => folder.name);
      }

      async function fetchImages(folder) {
        const response = await fetch(
          `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DESIGN_FOLDER}/${folder}`
        );
        const files = await response.json();
        return files
          .filter((file) => /\.(jpg|jpeg|png|gif)$/i.test(file.name))
          .map((file) => ({
            name: file.name,
            url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/${DESIGN_FOLDER}/${folder}/${file.name}`
          }));
      }

      async function fetchMaterials() {
        const response = await fetch(
          `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${MATERIAL_FOLDER}`
        );
        const files = await response.json();
        return files
          .filter((file) => /\.(jpg|jpeg|png|gif)$/i.test(file.name))
          .map((file) => ({
            name: file.name,
            url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main/${MATERIAL_FOLDER}/${file.name}`
          }));
      }

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.crossOrigin = "Anonymous";
          img.src = src;
        });
      }

      async function updatePreview() {
        const selectedDesign = designSelect.value;
        const selectedMaterial = materialSelect.value;

        if (selectedDesign) {
          try {
            const designImg = await loadImage(selectedDesign);
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            const canvasRatio = previewCanvas.width / previewCanvas.height;
            const imageRatio = designImg.width / designImg.height;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (canvasRatio > imageRatio) {
              drawHeight = previewCanvas.height;
              drawWidth = drawHeight * imageRatio;
              offsetX = (previewCanvas.width - drawWidth) / 2;
              offsetY = 0;
            } else {
              drawWidth = previewCanvas.width;
              drawHeight = drawWidth / imageRatio;
              offsetX = 0;
              offsetY = (previewCanvas.height - drawHeight) / 2;
            }

            ctx.drawImage(designImg, offsetX, offsetY, drawWidth, drawHeight);

            if (selectedMaterial && selectedMaterial !== "No Material") {
              try {
                const materialImg = await loadImage(selectedMaterial);
                const designData = ctx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
                const materialCanvas = document.createElement("canvas");
                const materialCtx = materialCanvas.getContext("2d");
                materialCanvas.width = previewCanvas.width;
                materialCanvas.height = previewCanvas.height;
                materialCtx.drawImage(materialImg, offsetX, offsetY, drawWidth, drawHeight);
                const materialData = materialCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

                const threshold = 60; // Schwellenwert f√ºr dunkle Bereiche

                for (let i = 0; i < designData.data.length; i += 4) {
                  const r = designData.data[i];
                  const g = designData.data[i + 1];
                  const b = designData.data[i + 2];
                  const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

                  if (brightness < threshold) { // Material nur auf den dunkelsten Pixeln anwenden
                    designData.data[i] = materialData.data[i];
                    designData.data[i + 1] = materialData.data[i + 1];
                    designData.data[i + 2] = materialData.data[i + 2];
                  }
                }

                ctx.putImageData(designData, 0, 0);
              } catch (err) {
                console.error("Fehler beim Laden des Materialbilds:", err);
              }
            }

            // Zeichnet die Maske, falls vorhanden
            if (maskRect) {
              ctx.save();
              ctx.strokeStyle = "red";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(maskRect.x + maskRect.radius, maskRect.y);
              ctx.lineTo(maskRect.x + maskRect.width - maskRect.radius, maskRect.y);
              ctx.quadraticCurveTo(maskRect.x + maskRect.width, maskRect.y, maskRect.x + maskRect.width, maskRect.y + maskRect.radius);
              ctx.lineTo(maskRect.x + maskRect.width, maskRect.y + maskRect.height - maskRect.radius);
              ctx.quadraticCurveTo(maskRect.x + maskRect.width, maskRect.y + maskRect.height, maskRect.x + maskRect.width - maskRect.radius, maskRect.y + maskRect.height);
              ctx.lineTo(maskRect.x + maskRect.radius, maskRect.y + maskRect.height);
              ctx.quadraticCurveTo(maskRect.x, maskRect.y + maskRect.height, maskRect.x, maskRect.y + maskRect.height - maskRect.radius);
              ctx.lineTo(maskRect.x, maskRect.y + maskRect.radius);
              ctx.quadraticCurveTo(maskRect.x, maskRect.y, maskRect.x + maskRect.radius, maskRect.y);
              ctx.stroke();
              ctx.restore();
            }

          } catch (err) {
            console.error("Fehler beim Laden des Designbilds:", err);
          }
        }
      }

      async function handleManufacturerChange() {
        const selectedManufacturer = manufacturerSelect.value;
        if (selectedManufacturer && selectedManufacturer !== "Select Manufacturer") {
          const images = await fetchImages(selectedManufacturer);
          const models = [...new Set(images.map((image) => image.name.split("_")[0]))];
          populateDropdown(
            modelSelect,
            models.map((model) => ({ name: model, url: model }))
          );

          if (models.length > 0) {
            modelSelect.value = models[0].url;
            await handleModelChange(); // Modelle abrufen und Dropdown f√ºllen
          }
        }
      }

      async function handleModelChange() {
        const selectedManufacturer = manufacturerSelect.value;
        const selectedModel = modelSelect.value;
        if (selectedManufacturer && selectedModel) {
          const images = await fetchImages(selectedManufacturer);
          const designs = images
            .filter((image) => image.name.startsWith(selectedModel))
            .map((image) => ({
              name: image.name.split("_")[1],
              url: image.url
            }));
          populateDropdown(designSelect, designs);

          if (designs.length > 0) {
            designSelect.value = designs[0].url;
            updatePreview();
          }
        }
      }

      manufacturerSelect.addEventListener("change", handleManufacturerChange);
      modelSelect.addEventListener("change", handleModelChange);

      const manufacturers = await fetchFolders(DESIGN_FOLDER);
      populateDropdown(
        manufacturerSelect,
        manufacturers.map((manufacturer) => ({
          name: manufacturer,
          url: manufacturer
        })),
        false
      );
      manufacturerSelect.value = "Select Manufacturer";

      const materials = await fetchMaterials();
      populateDropdown(materialSelect, materials);
      materialSelect.insertAdjacentHTML(
        "afterbegin",
        '<option value="No Material" selected>No Material</option>'
      );

      designSelect.addEventListener("change", updatePreview);
      materialSelect.addEventListener("change", updatePreview);

      // Initiale Vorschau-Aktualisierung
      if (designSelect.options.length > 0 && modelSelect.options.length > 0) {
        updatePreview();
      }

      // Event-Handler f√ºr Dev-Tools
      devToolsButton.addEventListener("click", () => {
        drawing = !drawing;
        devToolsButton.textContent = drawing ? "Dev-Tools deaktivieren" : "Dev-Tools aktivieren";
      });

      // Event-Handler f√ºr Zeichnen der Maske
      previewCanvas.addEventListener("mousedown", (event) => {
        if (drawing) {
          const rect = previewCanvas.getBoundingClientRect();
          const startX = event.clientX - rect.left;
          const startY = event.clientY - rect.top;

          previewCanvas.addEventListener("mousemove", onMouseMove);
          previewCanvas.addEventListener("mouseup", onMouseUp);

          function onMouseMove(moveEvent) {
            const currentX = moveEvent.clientX - rect.left;
            const currentY = moveEvent.clientY - rect.top;
            const width = currentX - startX;
            const height = currentY - startY;
            const radius = 20; // Abgerundete Ecken

            maskRect = { x: startX, y: startY, width, height, radius };
            updatePreview();
          }

          function onMouseUp() {
            previewCanvas.removeEventListener("mousemove", onMouseMove);
            previewCanvas.removeEventListener("mouseup", onMouseUp);
            // Speichert die Maske f√ºr zuk√ºnftige Verwendung
            localStorage.setItem('maskRect', JSON.stringify(maskRect));
          }
        }
      });

      // L√§dt gespeicherte Maske
      const savedMask = localStorage.getItem('maskRect');
      if (savedMask) {
        maskRect = JSON.parse(savedMask);
        updatePreview();
      }
    });
  </script>
</body>
</html>
